Guidance Board — Source Overview
===============================


Scope
* Focus: Guidance (positioning while in the air) — sensors, guidance control loops, CAN interfaces, and interactions with levitation and power boards.
* Not covered: Low-level levitation PWM implementation details that are handled on `levitation-board` (only the guidance control side and how guidance commands are sent/received are covered).

Key Concepts
* Two high-level system states: `OFF` (everything disabled) and `ON` (all components expected to be powered and operating). The guidance code verifies required components are enabled before commanding coils.
* Separation of concerns: Levitation keeps the pod vertically stable; guidance applies lateral forces using coils to position the pod relative to the track.
* Timing-critical operations: Guidance commands synchronize with very fast levitation control (microsecond to sub-millisecond domain). Guidance runs at a lower rate than the levitation loop but must respect levitation timing windows when commanding coil currents.

PWM, H-Bridge and Deadtime (Overview)
* Guidance influences coil currents by requesting current/voltage setpoints. The physical driver uses H-bridges in the levitation boards to route current through coils.
* H-bridge vs two switches: An H-bridge simplifies switching both polarities; only one bridge side conducts at a time to produce current through the coil.
* Deadtime: A short deadtime exists between switching opposite bridge legs. During deadtime both transistors on one side are open to avoid shoot-through. Deadtime is required to protect transistors if tiny overlap occurs.
* Phase relationship: One bridge may be driven in a pattern such that only when the correct legs are active does current run through the coil.

ADC and Sensors
* Guidance board reads distance/position sensors (optical, ultrasonic, LVDT, or similar) and system sensors via ADC inputs.
* Current sensing: Small sense resistors measure current. ADC timing is critical — current measurement is typically sampled right after an actuator switching event (timing aligned to PWM/actuation).
* Voltage domains: Coil supply is high-voltage (≈45 V nominal for coils). Board logic and MCU run on 5 V (derived from a regulator). Guidance must check voltages and refuse to command coils below configured safe thresholds.
* Periodic readings: Non-time-critical sensor reads (temperatures, telemetry) run at low rates (e.g., <100 Hz). Guidance and levitation loops run much faster.

CAN bus & Messaging (canzero)
* The project uses CAN for inter-board communications; `canzero` is the autogeneration tooling that produces CAN IDs and message definitions from a YAML config.
* CAN frame structure: `ID`, `DLC` (data length), `data`, and CRC/diagnostic fields are used like standard CAN frames.
* Broadcast model: Messages are broadcast to all MCUs; each MCU decides whether to consume a message. The system has two CAN buses; messages can be split across them.
* Autogenerated bindings: The canzero-generated code defines message IDs, packing/unpacking, fixed-point formats, and intervals. Check `src/canzero/` for generated sources.
* Sending policy: Messages can be periodic, event-driven, or send-on-change depending on configuration.

State Machine (Process & Safety)
* Each MCU has a local state machine; a global/master state machine coordinates the pod’s lifecycle.
* Typical process states: `INIT` -> hardware checks & precharge -> `READY` -> `LEVITATION_START` -> `LEVITATION_STABLE` -> `GUIDANCE_START` -> `GUIDANCE_STABLE` -> `RUNNING`. Any fault or missing part transitions to `IDLE`/`OFF`.
* Controller interaction: Guidance will not enable coil commands until levitation reports stable. UI buttons can step the global state machine forward or backward in controlled steps.
* Shutdown/disarm: On certain faults (e.g., cooling fail) or manual disarm, the system brings the coil supply down safely (precharge discharge, PDUs power down) before entering `IDLE`.

Guidance Control Flow (high level)
* Sensor -> Filter -> Controller -> Actuator demand: Measurements are filtered, fed into PID/PI controllers to compute desired correction, then converted to a current request for the levitation power stage.
* Two-stage control: Guidance supplies a lateral airgap target. Levitation boards convert that into current references and run inner PI loops using local current measurements to produce PWM outputs.
* Local vs remote control: Levitation boards perform very fast inner loops locally. Guidance performs slower position control and uses CAN to send setpoints.

Where to find the code (important files)
* `src/main.cpp` — startup, peripheral init (CAN, ADC, IRQ), and board-level state machine.
* `src/control.cpp` / `src/control.h` — guidance control logic (filtering, PID/PI, conversion to current/setpoint).
* `src/adc_isr.cpp` and `src/adc_config.h` — ADC configuration and ISR; timing-sensitive ADC reads for current/position sensors are here.
* `src/pwm_config.h` — PWM configuration and duty-cycle mapping (guidance influences these indirectly via setpoints).
* `src/handle_heartbeat.cpp` — CAN heartbeats / health publication.
* `src/print.cpp` / `src/print.h` — logging and debug helpers.
* `src/fsm/` — local finite state machine implementations.
* `src/can/` and `src/canzero/` — CAN stack and generated canzero bindings.
* `src/sensors/` — sensor drivers and helpers.
* `src/firmware/` — board-specific firmware helpers (safety, precharge, PDU interface).

Mocks and Testing
* Use `mock/` to run TCP-based CAN mocks for local testing (`canzero` dump and UI emulation). Mocks allow exercising guidance logic without hardware.

Safety & Protections
* Voltage thresholds: Guidance checks supplies and will not command coils if coil supply is below safe limits (nominal coil supply ~45 V).
* Short-circuit detection: Power boards monitor current and report faults; guidance subscribes to these health messages and will enter safe states on fault.
* Deadtime & H-bridge safety: Guidance assumes levitation drivers enforce deadtime and PWM interlocks and must not request switching that violates safe intervals.

Build & Run (quick notes)
* Build with the workspace toolchain (PlatformIO / CMake). From the workspace root:
```
cd guidance-board
# build depends on project setup; typically:
platformio run
# or use the provided CMake/extra scripts
```
* Use `mock/` for high-level tests before flashing hardware.

Telemetry & UI
* A telemetry bridge translates CAN to Ethernet/Wi‑Fi to connect to the control UI. Guidance publishes telemetry (position, errors, setpoints) which is relayed by the telemetry board.

Notes on Data Types & Autogeneration
* Fixed-point formats are used broadly. `canzero` config defines packing and scaling used by all MCUs — search the `canzero` files for the canonical definitions.
* Message IDs and definitions are autogenerated from YAML; this ensures consistent layouts, ID allocation, and intervals.

Where to look next
* Position control specifics: `src/control.cpp` and `src/sensors/`.
* ADC timing & current sampling: `src/adc_isr.cpp` and `src/adc_config.h`.
* CAN message defs and autogenerated APIs: `src/canzero/`.

Next options I can do for you
* Add per-function comments mapping to specific lines/files.
* Generate a small dataflow diagram (sensor -> guidance PID -> CAN -> levitation board -> coil) and embed it in this README.

=
This file focuses on guidance and intentionally avoids repeating low-level levitation PWM implementation details that are implemented on the levitation boards. It documents how guidance interacts with sensors, CAN, and levitation to position the pod while airborne.
