**Guidance Board — Source Map (readme3)**

This file guides a reader through the `guidance-board/src` tree, highlights the central files and functions, and explains what each important unit does and why it matters for guidance (positioning while levitated). At the end there is a clear list of what I intentionally omitted and why.

**How to use this file**: skim the central-file bullets first to get the control flow, then open the referenced source file to inspect the functions noted.

**Top-level flow**
- **`main.cpp`**: Entry point and main loop.
  - Responsibilities: initialize CAN (`canzero_init()`), board hardware (`guidance_board::begin()`), ADC, PWM, sensors and FSM; call periodic `update()` functions in a fixed order: CAN poll, board update, sensors update, ADC/ISR update, `control::update()`, FSM update, and canzero timing service.
  - Relevance: shows the runtime order and which modules are called each loop — essential to understand timing and data flow.

**Control & Actuation**
- **`control.cpp` / `control.h`**: Central guidance algorithm.
  - Key functions: `control::begin()`, `control::control_loop(...)`, `control::update()`.
  - What it does: implements the position (force) PID and the inner current PI controllers. The `control_loop` receives measured currents and multiple airgap distances and returns a `GuidancePwmControl` structure (four duty values) that describe desired PWM duties for left/right magnets.
  - Important internals to inspect: parameter tuning (Kp, Ki, Kd), the error filtering (`BoxcarFilter`), the EMAs used for current filtering, and the conversion from force target → current target → per-side PI targets. These are the places you tune behavior.
  - Relevance: this file contains the math that directly affects lateral positioning. When debugging guidance behavior, this is the first file to read.

- Notes about long/repetitive parts: `control.cpp` uses repeated PI blocks for left and right currents with the same structure — focus on a single PI block to understand both.

**Sensor acquisition & timing**
- **`adc_isr.cpp` / `adc_isr.h`**: ADC interrupt handling and timing-critical conversion.
  - Key functions: `adc_isr::begin()`, `adc_etc_done0_isr(AdcTrigRes res)`, `adc_isr::update()`.
  - What it does: converts ADC trigger results into typed units (Currents, Distances) by calling sensor conversion helpers (e.g., `sensors::magnet_current::conv_left()` and `sensors::airgaps::conv_left_lim()`), then calls `control::control_loop(...)` and forwards the returned `GuidancePwmControl` to `pwm::control()` (via a cast to `PwmControl`). This is the critical link — sensor reading → control math → PWM demand.
  - Relevance: timing here matters. The ADC ISR runs close to the levitation actuation and must sample at the right moment relative to PWM. Inspect `adc_etc_done0_isr` when verifying measurement timing and correctness.

**PWM configuration and safety**
- **`pwm_config.h`**: PWM setup.
  - Key items: `pwm_config()` builds `PwmBeginInfo` with `frequency = 20_kHz` and `deadtime = 1000_ns` plus trigger settings. `enable_outputs` defaulted to false.
  - Relevance: defines PWM frequency and deadtime which directly influence coil current shapes and safe switching. If you change timing parameters you must ensure ADC sampling and control math remain synchronized.

**Sensors** (common pattern)
- Folder: `src/sensors/` contains modules for each measurement type. Each module typically exposes `begin()`, `calibrate()`, and `update()` and conversion helpers like `conv_left()` / `conv_right()`.
  - `airgaps.cpp` / `airgaps.h`: conversion utilities for magnet airgap and limiter airgap sensors. These outputs are the primary inputs to the guidance PID.
  - `magnet_current.cpp` / `magnet_current.h`: current measurement for magnet coils; used by inner PI controllers and filtered with EMA.
  - `input_current.*`, `vdc.*`, `mcu_temperature.*`: health and system sensors used for safety and telemetry.
  - Relevance: sensor modules are the canonical place to find ADC→physical-unit conversion and calibration logic. When a measured value looks wrong, inspect the matching `sensors/*` module.

**CAN & message generation**
- `src/can/` and `src/canzero/`:
  - `can.cpp` / `can.hpp`: low-level CAN glue.
  - `canzero.cpp` / `canzero.h`: generated/handshake layer (auto-generated IDs, getter/setter stubs and time helpers). Call sites in `main.cpp` and `adc_isr.cpp` show how data is posted or read.
  - Relevance: messages are the bus-level contract. If you want to see which signals are published or which periodic intervals are used, inspect `src/canzero/canzero.cpp` (autogenerated) and the YAML config the project uses (not in this file but referenced when generating canzero).

**State machine and safety**
- `src/fsm/` (files: `fsm.cpp`, `fsm.h`, `states/`, `error_handling.*`):
  - Key functions: `fsm::begin()`, `fsm::finish_init()`, `fsm::update()` and state handlers inside `states/`.
  - What it does: orchestrates high-level transitions (`INIT` → `READY` → levitation/guidance start → `RUN`) and reacts to errors (precharge, voltage, temperature). Guidance will not enable actuation unless the FSM reports appropriate readiness.
  - Relevance: for workflow control, mission sequencing, and safe disarm — inspect the state handlers to see what preconditions are required for guidance to accept setpoints.

**Board/firmware helpers**
- `src/firmware/` (folder): contains board-specific hardware glue (e.g., precharge control, PDU commands, LED signals). These modules expose `begin()` and `update()` patterns and bridge high-level commands to hardware signals.
  - Relevance: important when you need to trace a software command to an actual pin or relay on the board.

**Utilities & support**
- `src/print.*` — logging and debug printing; useful during debugging but not part of control math.
- `src/sdc_brake.*` — safety braking interface; called from `main` loop and can affect guidance operation.
- `src/assert_err.cpp`, `error_level_range_check.h` — safety checks and error propagation utilities.

**Files that are long, auto-generated, or repetitive — what to focus on**
- `src/canzero/*` (auto-generated): contains many message helpers and repetitive packing/unpacking code. Focus on the top-level message names and the intervals/IDs; skip line-by-line repetition.
- `src/sensors/*` files: many sensor modules follow the same `begin()/calibrate()/update()` pattern. Read one module to understand the pattern, then skim the others for conversion constants.
- `src/firmware/*` and platform glue: long but usually hardware-specific. If you want to debug a pin/relay, inspect only the function that maps to that hardware signal.

**Quick file-to-function cheat-sheet (central items)**
- `main.cpp`: `main()` — initialization and main loop ordering.
- `control.cpp`/`control.h`: `control::begin()`, `control::control_loop(...)`, `control::update()` — PID/PI for guidance and current control.
- `adc_isr.cpp`/`adc_isr.h`: `adc_etc_done0_isr()` — convert ADC triggers → typed units, call `control::control_loop`, call `pwm::control()`.
- `pwm_config.h`: `pwm_config()` — sets frequency and deadtime used by levitation coil drivers.
- `sensors/airgaps.*`: `conv_*()` functions — convert ADC values to distances (these feed the PID).
- `sensors/magnet_current.*`: conversion to `Current` for inner PI loops.
- `fsm/*`: `fsm::begin()`, `fsm::finish_init()`, `fsm::update()` — state orchestration and safety gating.
- `canzero/*`: `canzero_init()`, polling functions and getters for shared telemetry (autogenerated interfaces).

**What I omitted and why**
- Low-level levitation PWM transistor timing internals and H-bridge driver code (likely in `levitation-board` or `firmware/` lower-level drivers): omitted because they are hardware-driver-level and not part of guidance algorithm logic. They are critical for hardware safety but do not change guidance math or strategy.
- Line-by-line contents of `src/canzero/*`: omitted because the canzero outputs are autogenerated packing/unpacking code that is repetitive — focus on message names, IDs, and intervals, not on repetitive helpers.
- Very small helper files and generic utilities (e.g., `print.*`, many trivial `firmware/*` wrappers): omitted from detailed descriptions because they are straightforward and do not influence guidance behavior directly.
- Platform-specific register and HAL setup code: omitted as it is required for hardware bring-up but not useful for understanding guidance algorithms.

If you want, I can expand any omitted part on demand (for example: show the actual CAN IDs and scales from `canzero.cpp`, create a simple diagram for the main dataflow, or annotate `control.cpp` line-by-line explaining each block).

---
End of `readme3` — file map and quick guide to the guidance sources.
